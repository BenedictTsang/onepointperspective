<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ä¸€é»é€è¦–ï¼šiPad è§¸æ§é€šç”¨ç‰ˆ</title>
    <style>
        /* é˜²æ­¢ iPad ä¸Šçš„æ©¡çš®ç­‹æ²å‹•æ•ˆæœ */
        body { margin: 0; display: flex; height: 100vh; font-family: 'Segoe UI', sans-serif; overflow: hidden; background-color: #f0f3f4; touch-action: none; }
        
        /* å·¦å´å·¥å…·æ¬„ */
        #toolbar {
            width: 260px; background: #2c3e50; color: white; padding: 20px;
            display: flex; flex-direction: column; gap: 12px; z-index: 10;
            box-shadow: 2px 0 10px rgba(0,0,0,0.2); user-select: none;
            overflow-y: auto; -webkit-overflow-scrolling: touch;
        }
        h2 { border-bottom: 1px solid #7f8c8d; padding-bottom: 10px; margin-top: 0; font-size: 1.2rem;}
        
        button {
            padding: 12px; background: #27ae60; color: white; border: none; border-radius: 8px;
            cursor: pointer; font-size: 1rem; font-weight: bold; transition: 0.2s; width: 100%;
            touch-action: manipulation; /* å„ªåŒ–è§¸æ§é»æ“Š */
        }
        button:active { transform: scale(0.98); }
        button.danger { background: #e74c3c; margin-top: 5px;}
        
        .color-toggles { display: flex; flex-direction: column; gap: 8px; margin-bottom: 10px;}
        .btn-toggle {
            display: flex; align-items: center; justify-content: space-between;
            background: #34495e; text-align: left; opacity: 1; padding: 10px;
        }
        .btn-toggle.inactive { opacity: 0.5; background: #2c3e50; text-decoration: line-through;}
        .color-indicator { width: 15px; height: 15px; border-radius: 50%; display: inline-block; margin-right: 8px; border: 2px solid white;}

        .control-group { background: rgba(0,0,0,0.2); padding: 12px; border-radius: 8px; margin-bottom: 5px;}
        label { display: block; margin-bottom: 5px; font-size: 0.9rem; color: #ecf0f1; font-weight: bold;}
        input[type=range] { width: 100%; height: 25px; cursor: pointer; }
        
        .info { font-size: 0.8rem; color: #bdc3c7; line-height: 1.4; margin-top: auto; padding-top: 10px;}

        #canvas-container { flex-grow: 1; position: relative; background: #85c1e9; overflow: hidden; touch-action: none;}
        svg { width: 100%; height: 100%; display: block; touch-action: none; }

        .ground { fill: #d5d8dc; }
        .sidewalk { fill: #ffffff; stroke: #bdc3c7; stroke-width: 1; }
        .street { fill: #566573; stroke: #2c3e50; stroke-width: 1; }
        .horizon-line { stroke: #c0392b; stroke-width: 2; }
        
        /* åŠ å¤§è§¸æ§å€ */
        .vp-handle { cursor: move; filter: drop-shadow(0 0 5px white); transition: r 0.2s; z-index: 1000;}
        
        .building-group { cursor: grab; }
        .face-front { fill: #3498db; stroke: #21618c; stroke-width: 2; vector-effect: non-scaling-stroke; }
        .face-side  { fill: #2ecc71; stroke: #1e8449; stroke-width: 2; vector-effect: non-scaling-stroke; }
        .face-top   { fill: #f1c40f; stroke: #d4ac0d; stroke-width: 1; vector-effect: non-scaling-stroke; }

        .guide-line { stroke-width: 2; fill: none; stroke-dasharray: 6,4; pointer-events: none; transition: opacity 0.3s; }

        .resize-handle { fill: white; stroke: #2980b9; stroke-width: 2; cursor: pointer; transition: r 0.1s; }
        /* iPad ä¸Šåœ“é»å¤§ä¸€é»æ¯”è¼ƒå¥½æŒ‰ */
        .resize-handle { r: 8; } 
        .active-handle { fill: #f1c40f; r: 10; }

    </style>
</head>
<body>

    <div id="toolbar">
        <h2>é€è¦–åŸå¸‚ (iPadç‰ˆ)</h2>
        
        <div class="control-group">
            <label>é¦¬è·¯å¯¬åº¦</label>
            <input type="range" id="streetSlider" min="20" max="500" value="250" oninput="updateEnvironment()">
        </div>
        <div class="control-group">
            <label>è¡Œäººè·¯å¯¬åº¦</label>
            <input type="range" id="sidewalkSlider" min="0" max="200" value="60" oninput="updateEnvironment()">
        </div>

        <div class="control-group">
            <label>è¼”åŠ©ç·šé–‹é—œ</label>
            <div class="color-toggles">
                <button class="btn-toggle" onclick="toggleLineColor(0, this)">
                    <span><span class="color-indicator" style="background: #FF0000;"></span>ç´…è‰²</span> <span>ğŸ‘ï¸</span>
                </button>
                <button class="btn-toggle" onclick="toggleLineColor(1, this)">
                    <span><span class="color-indicator" style="background: #FF8C00;"></span>æ©™è‰²</span> <span>ğŸ‘ï¸</span>
                </button>
                <button class="btn-toggle" onclick="toggleLineColor(2, this)">
                    <span><span class="color-indicator" style="background: #9b59b6;"></span>ç´«è‰²</span> <span>ğŸ‘ï¸</span>
                </button>
                <button class="btn-toggle" onclick="toggleLineColor(3, this)">
                    <span><span class="color-indicator" style="background: #000000;"></span>é»‘è‰²</span> <span>ğŸ‘ï¸</span>
                </button>
            </div>
        </div>

        <div>
            <button onclick="addBuilding()">+ åŠ å…¥å»ºç¯‰ç‰©</button>
            <button class="danger" onclick="clearBuildings()">æ¸…é™¤æ‰€æœ‰å»ºç¯‰</button>
        </div>
    </div>

    <div id="canvas-container">
        <svg id="mainSvg" 
             onmousemove="drag(event)" ontouchmove="drag(event)" 
             onmouseup="endDrag(event)" ontouchend="endDrag(event)"
             onmousedown="deselectAll(event)">
            
            <rect id="ground-rect" class="ground" />
            <polygon id="sidewalk-poly" class="sidewalk" />
            <polygon id="street-poly" class="street" />
            <line id="horizon" class="horizon-line" />
            <g id="buildings-layer"></g>
            <g id="guide-lines-layer"></g>
            <g id="controls-layer"></g>
            <circle id="vp-point" class="vp-handle" cx="0" cy="0" r="10" fill="red" stroke="white" stroke-width="3" />
        </svg>
    </div>

    <script>
        const svg = document.getElementById('mainSvg');
        const buildingsLayer = document.getElementById('buildings-layer');
        const guideLayer = document.getElementById('guide-lines-layer');
        const controlsLayer = document.getElementById('controls-layer');
        
        const horizonLine = document.getElementById('horizon');
        const streetPoly = document.getElementById('street-poly');
        const sidewalkPoly = document.getElementById('sidewalk-poly');
        const groundRect = document.getElementById('ground-rect');
        const vpPoint = document.getElementById('vp-point');
        
        const streetSlider = document.getElementById('streetSlider');
        const sidewalkSlider = document.getElementById('sidewalkSlider');

        let width, height, vpX, vpY;
        let selectedBuilding = null;
        let dragMode = null;
        let activeHandleIndex = -1;
        let offset = { x: 0, y: 0 };
        let startProps = {};

        const LINE_COLORS = ['#FF0000', '#FF8C00', '#9b59b6', '#000000']; 
        let colorVisibility = [true, true, true, true]; 
        let buildingCounter = 0; 

        function initScene() {
            width = svg.clientWidth;
            height = svg.clientHeight;
            if (!vpX) vpX = width / 2;
            if (!vpY) vpY = height / 2;
            updateEnvironment();
        }

        function updateEnvironment() {
            vpPoint.setAttribute('cx', vpX);
            vpPoint.setAttribute('cy', vpY);
            horizonLine.setAttribute('x1', 0); horizonLine.setAttribute('y1', vpY);
            horizonLine.setAttribute('x2', width); horizonLine.setAttribute('y2', vpY);
            groundRect.setAttribute('x', 0); groundRect.setAttribute('y', vpY);
            groundRect.setAttribute('width', width); groundRect.setAttribute('height', Math.max(0, height - vpY));

            const streetW = parseInt(streetSlider.value);
            const extraSidewalkW = parseInt(sidewalkSlider.value);
            const totalSidewalkW = streetW + extraSidewalkW;

            const stP1 = `${vpX},${vpY}`;
            const stP2 = `${vpX + streetW},${height}`;
            const stP3 = `${vpX - streetW},${height}`;
            streetPoly.setAttribute('points', `${stP1} ${stP2} ${stP3}`);

            const swP1 = `${vpX},${vpY}`;
            const swP2 = `${vpX + totalSidewalkW},${height}`;
            const swP3 = `${vpX - totalSidewalkW},${height}`;
            sidewalkPoly.setAttribute('points', `${swP1} ${swP2} ${swP3}`);

            updateAllBuildings();
            if (selectedBuilding) updateSelectionHandles(selectedBuilding);
        }

        window.addEventListener('resize', () => {
            width = svg.clientWidth;
            height = svg.clientHeight;
            updateEnvironment();
        });
        setTimeout(initScene, 0);

        function toggleLineColor(index, btn) {
            colorVisibility[index] = !colorVisibility[index];
            if (colorVisibility[index]) {
                btn.classList.remove('inactive');
                btn.querySelectorAll('span')[2].innerText = 'ğŸ‘ï¸';
            } else {
                btn.classList.add('inactive');
                btn.querySelectorAll('span')[2].innerText = 'âŒ';
            }
            updateLineVisibility();
        }

        function updateLineVisibility() {
            const groups = guideLayer.querySelectorAll('g');
            groups.forEach(g => {
                const cIndex = parseInt(g.dataset.colorIndex);
                if (!isNaN(cIndex)) {
                    g.style.display = colorVisibility[cIndex] ? 'block' : 'none';
                }
            });
        }

        function addBuilding() {
            const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            g.setAttribute('class', 'building-group');
            
            const startW = 80;
            const startH = 120;
            const startX = Math.random() * (width - 200) + 50;
            const startY = Math.max(vpY + 50, Math.random() * (height - startH - 50));

            g.dataset.x = startX;
            g.dataset.y = startY;
            g.dataset.w = startW;
            g.dataset.h = startH;
            g.id = 'b_' + Date.now();
            
            const colorIndex = buildingCounter % 4;
            g.dataset.colorIndex = colorIndex; 
            buildingCounter++; 

            const top = document.createElementNS("http://www.w3.org/2000/svg", "polygon"); top.setAttribute('class', 'face-top');
            const side = document.createElementNS("http://www.w3.org/2000/svg", "polygon"); side.setAttribute('class', 'face-side');
            const front = document.createElementNS("http://www.w3.org/2000/svg", "rect"); front.setAttribute('class', 'face-front');
            
            g.appendChild(top); g.appendChild(side); g.appendChild(front);
            buildingsLayer.appendChild(g);

            // æ”¯æ´æ»‘é¼ èˆ‡è§¸æ§
            g.addEventListener('mousedown', (e) => onBuildingStart(e, g));
            g.addEventListener('touchstart', (e) => onBuildingStart(e, g), {passive: false});

            updateSingleBuilding(g);
            selectBuilding(g);
        }

        function updateSingleBuilding(g) {
            let x = parseFloat(g.dataset.x);
            let y = parseFloat(g.dataset.y);
            let w = parseFloat(g.dataset.w);
            let h = parseFloat(g.dataset.h);
            let cIndex = parseInt(g.dataset.colorIndex);

            const frontEl = g.querySelector('.face-front');
            const sideEl = g.querySelector('.face-side');
            const topEl = g.querySelector('.face-top');

            frontEl.setAttribute('x', x); frontEl.setAttribute('y', y);
            frontEl.setAttribute('width', w); frontEl.setAttribute('height', h);

            const fl_tl = {x: x, y: y};
            const fl_tr = {x: x + w, y: y};
            const fl_bl = {x: x, y: y + h};
            const fl_br = {x: x + w, y: y + h};

            const depthFactor = 0.25;
            function project(p) { return { x: p.x + (vpX - p.x) * depthFactor, y: p.y + (vpY - p.y) * depthFactor }; }
            const bl_tl = project(fl_tl); const bl_tr = project(fl_tr);
            const bl_br = project(fl_br); const bl_bl = project(fl_bl);

            const centerX = x + w/2;
            const isLeft = centerX < vpX;
            let sidePoints = isLeft 
                ? `${fl_tr.x},${fl_tr.y} ${bl_tr.x},${bl_tr.y} ${bl_br.x},${bl_br.y} ${fl_br.x},${fl_br.y}`
                : `${fl_tl.x},${fl_tl.y} ${bl_tl.x},${bl_tl.y} ${bl_bl.x},${bl_bl.y} ${fl_bl.x},${fl_bl.y}`;
            sideEl.setAttribute('points', sidePoints);

            if (y > vpY) {
                topEl.setAttribute('points', `${fl_tl.x},${fl_tl.y} ${bl_tl.x},${bl_tl.y} ${bl_tr.x},${bl_tr.y} ${fl_tr.x},${fl_tr.y}`);
                topEl.style.display = "block";
            } else { topEl.style.display = "none"; }

            drawGuideLinesForBuilding(g.id, fl_tl, fl_tr, fl_bl, fl_br, cIndex);
        }

        function updateAllBuildings() {
            document.querySelectorAll('.building-group').forEach(g => updateSingleBuilding(g));
        }

        function drawGuideLinesForBuilding(bid, p1, p2, p3, p4, cIndex) {
            let lineGroup = document.getElementById('lines-' + bid);
            if (!lineGroup) {
                lineGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
                lineGroup.id = 'lines-' + bid;
                lineGroup.dataset.colorIndex = cIndex;
                guideLayer.appendChild(lineGroup);
            }
            lineGroup.style.display = colorVisibility[cIndex] ? 'block' : 'none';

            let lines = lineGroup.querySelectorAll('line');
            if (lines.length === 0) {
                for(let i=0; i<4; i++) {
                    const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    l.setAttribute('class', 'guide-line');
                    lineGroup.appendChild(l);
                }
                lines = lineGroup.querySelectorAll('line');
            }
            const color = LINE_COLORS[cIndex];
            [p1, p2, p3, p4].forEach((p, i) => {
                lines[i].setAttribute('x1', p.x); lines[i].setAttribute('y1', p.y);
                lines[i].setAttribute('x2', vpX); lines[i].setAttribute('y2', vpY);
                lines[i].setAttribute('stroke', color);
            });
        }

        function selectBuilding(g) { selectedBuilding = g; updateSelectionHandles(g); }
        function deselectAll(e) {
            // åªåœ¨è§¸æ§æˆ–é»æ“ŠèƒŒæ™¯æ™‚å–æ¶ˆé¸å–
            if (e.target.id === 'mainSvg' || e.target.classList.contains('ground') || e.target.classList.contains('street') || e.target.classList.contains('sidewalk')) {
                selectedBuilding = null; controlsLayer.innerHTML = '';
            }
        }
        function updateSelectionHandles(g) {
            controlsLayer.innerHTML = ''; if (!g) return;
            const x = parseFloat(g.dataset.x); const y = parseFloat(g.dataset.y);
            const w = parseFloat(g.dataset.w); const h = parseFloat(g.dataset.h);
            const corners = [{x: x, y: y}, {x: x + w, y: y}, {x: x + w, y: y + h}, {x: x, y: y + h}];
            
            corners.forEach((c, index) => {
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute('cx', c.x); circle.setAttribute('cy', c.y);
                circle.setAttribute('class', 'resize-handle');
                // æ”¯æ´æ»‘é¼ èˆ‡è§¸æ§
                circle.addEventListener('mousedown', (e) => onHandleStart(e, index, g));
                circle.addEventListener('touchstart', (e) => onHandleStart(e, index, g), {passive: false});
                controlsLayer.appendChild(circle);
            });
        }

        // --- æ ¸å¿ƒï¼šçµ±ä¸€è™•ç† Mouse å’Œ Touch äº‹ä»¶ ---
        
        // å–å¾—åº§æ¨™ (è‡ªå‹•åˆ¤æ–·æ˜¯æ»‘é¼ é‚„æ˜¯è§¸æ§)
        function getPoint(evt) {
            const pt = svg.createSVGPoint();
            if (evt.touches && evt.touches.length > 0) {
                pt.x = evt.touches[0].clientX;
                pt.y = evt.touches[0].clientY;
            } else {
                pt.x = evt.clientX;
                pt.y = evt.clientY;
            }
            return pt.matrixTransform(svg.getScreenCTM().inverse());
        }

        function onBuildingStart(e, g) {
            e.preventDefault(); e.stopPropagation(); // é˜²æ­¢æ²å‹•ç•«é¢
            selectBuilding(g); dragMode = 'move';
            const pt = getPoint(e);
            offset.x = pt.x - parseFloat(g.dataset.x); offset.y = pt.y - parseFloat(g.dataset.y);
        }

        function onHandleStart(e, index, g) {
            e.preventDefault(); e.stopPropagation();
            dragMode = 'resize'; activeHandleIndex = index; selectedBuilding = g;
            e.target.classList.add('active-handle'); // é«˜äº®é¡¯ç¤º
            startProps = {
                x: parseFloat(g.dataset.x), y: parseFloat(g.dataset.y),
                w: parseFloat(g.dataset.w), h: parseFloat(g.dataset.h),
                mx: getPoint(e).x, my: getPoint(e).y
            };
        }

        // ç¶å®š VP çš„è§¸æ§èˆ‡æ»‘é¼ 
        vpPoint.addEventListener('mousedown', (e) => { e.stopPropagation(); dragMode = 'vp'; });
        vpPoint.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); dragMode = 'vp'; }, {passive: false});

        function drag(evt) {
            if (!dragMode) return; 
            evt.preventDefault(); // éå¸¸é‡è¦ï¼šé˜²æ­¢ iPad ç•«é¢è¢«æ‹–å‹•
            const pt = getPoint(evt);

            if (dragMode === 'vp') { vpX = pt.x; vpY = pt.y; updateEnvironment(); } 
            else if (dragMode === 'move' && selectedBuilding) {
                selectedBuilding.dataset.x = pt.x - offset.x; selectedBuilding.dataset.y = pt.y - offset.y;
                updateSingleBuilding(selectedBuilding); updateSelectionHandles(selectedBuilding);
            }
            else if (dragMode === 'resize' && selectedBuilding) {
                let dx = pt.x - startProps.mx; let dy = pt.y - startProps.my;
                let nx=startProps.x, ny=startProps.y, nw=startProps.w, nh=startProps.h;
                
                if (activeHandleIndex === 2) { nw+=dx; nh+=dy; } 
                else if (activeHandleIndex === 1) { nw+=dx; ny+=dy; nh-=dy; }
                else if (activeHandleIndex === 3) { nx+=dx; nw-=dx; nh+=dy; }
                else if (activeHandleIndex === 0) { nx+=dx; ny+=dy; nw-=dx; nh-=dy; }

                if (nw < 20) { nw = 20; if(activeHandleIndex===0||activeHandleIndex===3) nx = startProps.x + startProps.w - 20; }
                if (nh < 20) { nh = 20; if(activeHandleIndex===0||activeHandleIndex===1) ny = startProps.y + startProps.h - 20; }
                
                selectedBuilding.dataset.x = nx; selectedBuilding.dataset.y = ny;
                selectedBuilding.dataset.w = nw; selectedBuilding.dataset.h = nh;
                updateSingleBuilding(selectedBuilding); updateSelectionHandles(selectedBuilding);
            }
        }

        function endDrag(evt) { 
            dragMode = null; activeHandleIndex = -1; 
            // ç§»é™¤æ‰€æœ‰æ§åˆ¶é»çš„é«˜äº®
            document.querySelectorAll('.active-handle').forEach(el => el.classList.remove('active-handle'));
        }
        function clearBuildings() {
            buildingsLayer.innerHTML = ''; guideLayer.innerHTML = ''; controlsLayer.innerHTML = '';
            selectedBuilding = null; buildingCounter = 0;
        }

    </script>
</body>
</html>